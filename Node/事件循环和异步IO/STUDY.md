### 什么是时间循环

- 我把时间循环理解为我们编写的 JavaScript 和 浏览器或者 Node 之间的桥梁

### 进程和线程

- 进程(process): 计算机已经运行的程序
  - 启动一个 应用程序, 会默认启动一个进程(也可能多个进程)
- 线程(thread): 操作系统能够运行运算调度的最小单位
  - 每一个进程中, 都会启动一个线程来执行程序中的代码, 称为主线程
- 进程是线程的容器

- 举例:
  - 操作系统类似工厂
  - 工厂有很多车间, 车间就是进程
  - 每个车间有工人, 工人就是线程

### 宏任务 微任务

事件循环维护两个队列:

- 宏任务队列: ajax setTimeout setInterval DOM监听 UI Rending
- 微任务队列: Promise的then回调 Mutation Observer API queneMicrotask() 等


优先级:

1. 顶层 script 代码先执行
2. 在执行任何一个宏任务之前, 查看微任务队列是否有任务需要执行
   1. 宏任务执行之前, 必须保证微任务队列是空的
   2. 不为空, 优先执行微任务队列中的任务

async await 是 Promise 的一个语法糖

- await xxx 相当于 new Promise 立即执行
- await 下面相当于 .then 中 微任务回调


### Node 的事件循环

- Node 的事件循环, 是一个无限循环, 循环体中包含两个队列
- Node 中是由 libuv 实现
  - libuv 主要维护了一个 EventLoop 和 worker threads(线程池)


### 阻塞IO 和 非阻塞IO

如果对文件操作, 需要打开这个文件: 通过文件描述符
  - Js 可以直接对一个文件进行操作码?
  - 看起来可以, 但是事实任何程序的文件操作都需要进行`系统调用` (操作系统的文件系统)
  - 对文件的操作, 是一个操作系统的 系统调用 (IO系统,  IO是输入 输出)

操作系统提供了两种调用方式:  `阻塞式调用 非阻塞式调用`
  - 阻塞调用: 结果返回之前, 线程处于阻塞
  - 非阻塞: 调用执行之后, 当前线程不会停止执行
开发的很多耗时操作, 都是 非阻塞调用
  - 网络请求 Socket通信
  - 文件读写的 IO操作

### 非阻塞IO的问题

没有获取需要 读取的结果
  - 为了可以知道是否读取到了完整的数据, 需要频繁的去确定读取到的数据是否是完整的; 这个过程是轮询
  - libuv 提供了一个线程池, 会负责所有相关操作

### 阻塞和非阻塞, 同步和异步

阻塞和非阻塞是对于 被调用者来说的;
  - 在我们这里就是系统调用, 操作系统为我们提供了阻塞调用和非阻塞调用
  
同步和异步是对于调用者来说的
  - 在这里就是自己的程序
  - 同步调用: 发起调用之后, 不会进行其它任何操作, 等待结果
  - 异步调用: 发起调用, 不等待结果, 继续完成其它的工作